# -----------------------------------------------------------------------------
# Pella-Tomlinson Model function
# -----------------------------------------------------------------------------
PT.model <- function(params, C_hist, I_hist, CMCsum, returnOpt=1, doPlot=FALSE)
{
  # Model parameters
  # B(t+1)=B(t) + (r/p)B(1-(B/K)^p) - C    ; MSY = rK/((p+1)^(1+(1/p)))
  #
  Y    <- length(C_hist)
  r    <- exp(params[1])
  K    <- exp(params[2])
  p    <- exp(params[3])
  B    <- array(NA,dim=Y)
  B[1] <- K

  for(y in 2:Y)
  {
    B[y] <- B[y-1] + (r * B[y-1] / p) * (1.0 - (B[y-1] / K)^p) - C_hist[y-1]

    if (B[y]<1e-5)
    {
      B[y] <- 1e-5
    }
  }

  ix
  q   <- sum(I_hist[!is.na(I_hist)])/sum(B[!is.na(I_hist)])
  LLH <- sum((q*B[!is.na(I_hist)]-I_hist[!is.na(I_hist)])^2)
  MSY <- r * K / (( p+ 1.0)^(1.0 + 1.0 / p))

  if (doPlot)
  {
    plot(I_hist / q, main="MSY: " %&% MSY %&% " C(Y)/MSY: " %&% as.character(CMCsum / MSY), ylim=c(0,max(I_hist / q, na.rm=T)))
    lines(B)
    lines(C_hist, col=2)
  }

  if (returnOpt == 1)
  {
    # return objective function
    return(LLH)
  }
  else
  {
    # return MSY-related stuff
    BMSY           <- MSY / r
    outList        <- c(B[Y], K, MSY, BMSY)
    names(outList) <- c("BY","K","MSY","BMSY")

    return(outList)
  }
}

# -----------------------------------------------------------------------------
# AD adjoint of PT-model obtained by Tapenade AD of,
#
# MODULE COMMON
#
#  INTEGER, PARAMETER :: dim_stack
#
#  INTEGER Y
#  REAL C_hist(Y), I_hist(Y)
#
# END
#
#
# REAL FUNCTION PT(params)
#
#   USE COMMON
#
#   REAL, INTENT (IN) :: params(3), C_hist(Y), I_hist(Y), Y
#
#   REAL B(Y), q, r, K, p
#   INTEGER yi
#
#   r = EXP(params(1))
#   K = EXP(params(2))
#   p = EXP(params(3))
#
#   B(1) = K
#
#   DO yi=2,Y
#     B(yi) = B(yi-1) + (r * B(yi-1) / p) * (1.0 - (B(yi-1) / K)**p) - C_hist(yi-1)
#
#     IF (B(yi) .LT. 1e-5) THEN
#       B(yi) = 1e-5
#     ENDIF
#
#   END DO
#
#   q  = sum(I_hist) / sum(B)
#   PT = sum((q * B - I_hist)**2)
#
#   RETURN
#
# END
#
# to obtain,
#
#
# !        Generated by TAPENADE     (INRIA, Tropics team)
# !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
# !
# !  Differentiation of pt in reverse (adjoint) mode (with options i4 dr8 r4):
# !   gradient     of useful results: params pt
# !   with respect to varying inputs: params
# !   RW status of diff variables: params:incr pt:in-killed
# SUBROUTINE PT_B(params, paramsb, ptb)
#   USE COMMON_B
#   IMPLICIT NONE
#   REAL, INTENT(IN) :: params(3), c_hist(!y), i_hist(!y), y
#   REAL :: paramsb(3)
#   REAL :: b(!y), q, r, k, p
#   REAL :: bb(!y), qb, rb, kb, pb
#   INTEGER :: yi
#   INTRINSIC EXP
#   INTRINSIC SUM
#   INTEGER :: branch
#   REAL :: ptb
#   REAL :: pt
#   REAL :: temp2
#   REAL :: temp1
#   REAL :: temp0
#   REAL :: tempb2(!y)
#   REAL :: tempb1
#   REAL :: tempb0
#   REAL :: tempb
#   REAL :: temp
#   r = EXP(params(1))
#   k = EXP(params(2))
#   p = EXP(params(3))
#   b(1) = k
#   DO yi=2,!y
#     CALL PUSHREAL4(b(yi))
#     b(yi) = b(yi-1) + r*b(yi-1)/p*(1.0-(b(yi-1)/k)**p) - C_hist(yi-1)
#     IF (b(yi) .LT. 1e-5) THEN
#       CALL PUSHREAL4(b(yi))
#       b(yi) = 1e-5
#       CALL PUSHCONTROL1B(1)
#     ELSE
#       CALL PUSHCONTROL1B(0)
#     END IF
#   END DO
#   q = SUM(i_hist)/SUM(b)
#   temp2 = SUM(b)
#   bb = 0.0
#   tempb2 = 2*(q*b-!i_hist)*ptb
#   qb = SUM(b*tempb2)
#   bb = q*tempb2 - SUM(i_hist)*qb/temp2**2
#   kb = 0.0
#   pb = 0.0
#   rb = 0.0
#   DO yi=!y,2,-1
#     CALL POPCONTROL1B(branch)
#     IF (branch .NE. 0) THEN
#       CALL POPREAL4(b(yi))
#       bb(yi) = 0.0
#     END IF
#     CALL POPREAL4(b(yi))
#     temp0 = r/p
#     tempb = b(yi-1)*temp0*bb(yi)
#     temp = b(yi-1)/k
#     IF (temp .LE. 0.0 .AND. (p .EQ. 0.0 .OR. p .NE. INT(p))) THEN
#       tempb0 = 0.0
#     ELSE
#       tempb0 = -(p*temp**(p-1)*tempb/k)
#     END IF
#     temp1 = temp**p
#     tempb1 = b(yi-1)*(1.0-temp1)*bb(yi)/p
#     bb(yi-1) = bb(yi-1) + tempb0 + ((1.0-temp1)*temp0+1.0)*bb(yi)
#     kb = kb - temp*tempb0
#     IF (temp .LE. 0.0) THEN
#       pb = pb - temp0*tempb1
#     ELSE
#       pb = pb - temp0*tempb1 - temp1*LOG(temp)*tempb
#     END IF
#     rb = rb + tempb1
#     bb(yi) = 0.0
#   END DO
#   kb = kb + bb(1)
#   paramsb(3) = paramsb(3) + EXP(params(3))*pb
#   paramsb(2) = paramsb(2) + EXP(params(2))*kb
#   paramsb(1) = paramsb(1) + EXP(params(1))*rb
# END SUBROUTINE PT_B
#
# and translated back to R code below. paramsb is set to zero and ptb set to one
#
# -----------------------------------------------------------------------------
PT.model.gradient <- function(params, C_hist, I_hist, CMCsum, returnOpt=1, doPlot=FALSE)
{
  Y       <- length(C_hist)
  paramsb <- array(as.double(NA), dim=c(3))
  b       <- array(as.double(NA), dim=c(Y))
  stackr  <- array(as.double(NA), dim=c(2 * Y))
  stacki  <- array(as.integer(NA), dim=c(Y))
  sr      <- 1
  si      <- 1
  r       <- exp(params[1])
  k       <- exp(params[2])
  p       <- exp(params[3])
  b[1]    <- k

  for (yi in 2:Y)
  {
    stackr[sr] <- b[yi]
    sr         <- sr + 1
    b[yi]      <- b[yi - 1] + r * b[yi - 1] / p * (1.0 - ((b[yi - 1] / k)^p)) - C_hist[yi - 1]

    if (b[yi] < 1.0e-5)
    {
      stackr[sr] <- b[yi]
      sr         <- sr + 1
      b[yi]      <- 1e-5
      stacki[si] <- 1
      si         <- si + 1
    }
    else
    {
      stacki[si] <- 0
      si         <- si + 1
    }
  }

  q       <- sum(I_hist) / sum(b)
  temp2   <- sum(b)
  bb      <- 0.0
  tempb2  <- 2.0 * (q * b - I_hist)
  qb      <- sum(b * tempb2)
  bb      <- q * tempb2 - sum(I_hist) * qb / (temp2^2)
  kb      <- 0.0
  pb      <- 0.0
  rb      <- 0.0

  for (yi in Y:2)
  {
    si     <- si - 1
    branch <- stacki[si]

    if (branch != 0)
    {
      sr    <- sr - 1
      b[yi] <- stackr[sr]
      bb[yi] <- 0.0
    }

    sr    <- sr - 1
    b[yi] <- stackr[sr]
    temp0 <- r / p
    tempb <- b[yi - 1] * temp0 * bb[yi]
    temp  <- b[yi - 1] / k

    if ((temp <= 0.0) && (p == 0.0) || (p != trunc(p)))
    {
      tempb0 <- 0.0
    }
    else
    {
      tempb0 <- -(p * (temp ^ (p - 1.0)) * tempb / k)
    }

    temp1      <- temp ^ p
    tempb1     <- b[yi - 1] * (1.0 - temp1) * bb[yi] / p
    bb[yi - 1] <- bb[yi - 1] + tempb0 + ((1.0 - temp1) * temp0 + 1.0) * bb[yi]
    kb         <- kb - temp * tempb0

    if (temp <= 0.0)
    {
      pb <- pb - temp0 * tempb1
    }
    else
    {
      pb <- pb - temp0 * tempb1 - temp1 * log(temp) * tempb
    }

    rb      <- rb + tempb1
    bb[yi]  <- 0.0
  }

  kb         <- kb + bb[1]
  paramsb[3] <- exp(params[3]) * pb
  paramsb[2] <- exp(params[2]) * kb
  paramsb[1] <- exp(params[1]) * rb

  paramsb

  return (paramsb)
}


MP_FunctionExports <- c(MP_FunctionExports, "PT.f")
